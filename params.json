{
  "name": "Eventsourcing",
  "tagline": "Event sourcing in Python",
  "body": "# Event Sourcing in Python\r\n\r\n[![Build Status](https://secure.travis-ci.org/johnbywater/eventsourcing.png?branch=develop)]\r\n(https://travis-ci.org/johnbywater/eventsourcing)\r\n\r\nA library for event sourcing in Python.\r\n\r\n\r\n## Features\r\n\r\n**Domain Events, Entities, Repositories, and Subscribers** — Base classes\r\nmake it easy to develop new applications with custom entities, custom\r\nrepositories, custom domain events, custom subscribers, custom\r\ntranscoders, custom stored event repositories, custom snapshotting\r\nmechanism. See example below, and the package's test suite.\r\n\r\n**Event Store** — With extendable set of stored event repositories\r\nfor adapting different ORMs and databases systems (e.g. Cassandra,\r\nSQLAlchemy). Includes an in-memory stored event\r\nrepository implemented with simple Python objects. If your\r\ndatabase system isn't already supported, it will be easy to adapt\r\nwith a custom stored event repository.\r\n\r\n**Event Player with Snapshots** — Avoid replaying an entire event stream to obtain the\r\ncurrent state of an entity. Makes entity access constant time,\r\nrather than proportional to the number of events. Snapshotting is\r\nimplemented as a strategy object in the application class, making it\r\neasy to use a custom snapshotting mechanism and storage. A snapshot\r\nstrategy is included which reuses the capabilities of this library by\r\nimplementing snapshots as domain events.\r\n\r\n**Fast Forwarding** — Of entities to latest published event, used with\r\nsnapshots and also when optimistic currency control exceptions are\r\nencountered.\r\n\r\n**Optimistic Concurrency Control** — Implemented using optimistic\r\nconcurrency controls in the adapted database. For example, with\r\nCassandra this accomplishes linearly-scalable distributed optimistic\r\nconcurrency control, guaranteeing sequential consistency of each\r\nevent stream, across a distributed application. It is also possible to\r\nserialize the execution of commands on an aggregate, but that is out\r\nof the scope of this package. If you wish to do that, perhaps something\r\nlike [Zookeeper](https://zookeeper.apache.org/) might help.\r\n\r\n**Application-Level Encryption** — Symmetric encryption of all stored\r\nevents, including snapshots and logged messages, using a customizable\r\ncipher. Can optionally be applied to encrypt particular events, or all\r\nstored events, or not applied at all (the default). Included is an AES\r\ncipher, by default in CBC mode with 128 bit blocksize, that uses a 16\r\nbyte encryption key passed in at run time, and which generates a\r\nunique 16 byte initialization vector for each encryption. Data is\r\ncompressed before it is encrypted, which can mean application\r\nperformance is improved when encryption is enabled.\r\n\r\n**Time-Bucketed Logs** — Provide a way of writing an indefinitely long\r\nstream of events in a highly scalable manner. Includes log objects,\r\nlogged message events and a log reader implemented as a generator that\r\ncan span across many many buckets. For example, a domain event log\r\nthat allows all stored events in an application to be logged in\r\na linearly scalable manner, and then retrieved in order, limited by\r\nnumber, from any point in time until another point in time, in reverse\r\nor ascending order.\r\n\r\n**Notification Logs** - Provide a way of reading an indefinitely long\r\nsequence of events in a highly scalable manner. Includes a notification\r\nlogger that writes an event sourced log that can be indexed with a\r\ncontiguous integer sequence, and a log reader implemented as a generator\r\nthat selects a part of a sequence using Python's list slice syntax.\r\n\r\n**Customizable Transcoding** — Between domain events and stored events,\r\nallows support to be added for serialization and deserialization of\r\ncustom value object types, and also makes it possible to use different\r\ndatabase schemas when developing a custom stored event repository.\r\n\r\n**Synchronous Publish-Subscribe Mechanism** — Entirely deterministic,\r\nwith handlers called in the order they are registered, and with which\r\ncalls to publish events do not return until all event subscribers have\r\nreturned.\r\n\r\n**Worked Examples** — A simple worked example application, with example\r\nentity class, event sourced repository, and factory method (see below).\r\nAlso included is a slightly more sophisticated version of the\r\nexample application below.\r\n\r\n**Collections** — Event sourced collections, for modelling different\r\nkinds of multiplicity.\r\n\r\n\r\n## Install\r\n\r\nUse pip to install the [latest distribution](https://pypi.python.org/pypi/eventsourcing) from\r\nthe Python Package Index.\r\n\r\n    pip install eventsourcing\r\n\r\nIf you want to run the test suite, or try the example below, then\r\nplease install with the optional extra called 'test'.\r\n\r\n    pip install eventsourcing[test]\r\n\r\nAfter installing with the 'test' optional extra, the test suite should\r\npass.\r\n\r\n    python -m unittest discover eventsourcing.tests -v\r\n\r\nPlease register any issues you find.\r\n\r\n* https://github.com/johnbywater/eventsourcing/issues\r\n\r\n\r\nThere is also a mailing list.\r\n\r\n* https://groups.google.com/forum/#!forum/eventsourcing-users\r\n\r\n\r\n## Usage\r\n\r\nStart by opening a new Python file in your favourite editor, or start\r\na new project in your favourite IDE (I've been using PyCharm for this\r\ncode).\r\n\r\nStart writing yourself a new event sourced entity class, by making a\r\nsubclass of 'EventSourcedEntity' (from module\r\n'eventsourcing.domain.model.entity').\r\n\r\n```python\r\nfrom eventsourcing.domain.model.entity import EventSourcedEntity, mutableproperty\r\n\r\n\r\nclass Example(EventSourcedEntity):\r\n    \"\"\"An example of an event sourced entity class.\"\"\"\r\n\r\n```\r\n\r\nThe entity class domain events must be defined on the domain entity\r\nclass. In the example below, an 'Example' entity defines 'Created',\r\n'AttributeChanged', and 'Discarded' events. Add these events to your\r\nentity class.\r\n\r\n```python\r\nfrom eventsourcing.domain.model.entity import EventSourcedEntity, mutableproperty\r\n\r\n\r\nclass Example(EventSourcedEntity):\r\n    \"\"\"An example of an event sourced entity class.\"\"\"\r\n\r\n    class Created(EventSourcedEntity.Created):\r\n        pass\r\n\r\n    class AttributeChanged(EventSourcedEntity.AttributeChanged):\r\n        pass\r\n\r\n    class Discarded(EventSourcedEntity.Discarded):\r\n        pass\r\n\r\n```\r\n\r\nWhen are these events published? The 'Created' event is published by a\r\nfactory method (see below), its values are used to initialise an\r\nentity. The 'Discarded' event is published by the discard() method,\r\nwhich is defined on class 'EventSourcedEntity'.\r\n\r\nThe 'mutableproperty' decorator is used to define mutable properties\r\n'a' and 'b'. The decorator introduces a setter that generates\r\n'AttributeChanged' events when values are assigned to the properties.\r\n\r\nAdd the two mutable properties 'a' and 'b' to your entity class.\r\n\r\n```python\r\nfrom eventsourcing.domain.model.entity import EventSourcedEntity, mutableproperty\r\n\r\n\r\nclass Example(EventSourcedEntity):\r\n    \"\"\"An example of an event sourced entity class.\"\"\"\r\n\r\n    class Created(EventSourcedEntity.Created):\r\n        pass\r\n\r\n    class AttributeChanged(EventSourcedEntity.AttributeChanged):\r\n        pass\r\n\r\n    class Discarded(EventSourcedEntity.Discarded):\r\n        pass\r\n\r\n    @mutableproperty\r\n    def a(self):\r\n        return self._a\r\n\r\n    @mutableproperty\r\n    def b(self):\r\n        return self._b\r\n```\r\n\r\nThat's everything you need to publish domain events. How are they\r\napplied?\r\n\r\nThe entity class inherits a mutator method that is capable of handling\r\nthose events. For example, when a 'Created' event is handled by the\r\nmutator, the attribute values of the Created event object are passed\r\ninto the entity class constructor. A factory method will instantiate a\r\nCreated event with the attribute values expected by the entity class\r\nconstructor.\r\n\r\nAdd a constructor to your entity class which takes two positional\r\narguments ('a' and 'b') and keyword arguments ('kwargs') which it\r\npasses through to the base class constructor.\r\n\r\n\r\n```python\r\nfrom eventsourcing.domain.model.entity import EventSourcedEntity, mutableproperty\r\n\r\n\r\nclass Example(EventSourcedEntity):\r\n    \"\"\"An example of an event sourced entity class.\"\"\"\r\n\r\n    class Created(EventSourcedEntity.Created):\r\n        pass\r\n\r\n    class AttributeChanged(EventSourcedEntity.AttributeChanged):\r\n        pass\r\n\r\n    class Discarded(EventSourcedEntity.Discarded):\r\n        pass\r\n\r\n    def __init__(self, a, b, **kwargs):\r\n        super(Example, self).__init__(**kwargs)\r\n        self._a = a\r\n        self._b = b\r\n\r\n    @mutableproperty\r\n    def a(self):\r\n        return self._a\r\n\r\n    @mutableproperty\r\n    def b(self):\r\n        return self._b\r\n\r\n```\r\n\r\n\r\nNext, define a factory method that returns new entity instances. Rather\r\nthan directly constructing the entity object instance, it should\r\nfirstly instantiate a 'Created' domain event, and then call the mutator\r\nto obtain an entity object. The factory method then publishes the event\r\n(for example, so that it might be saved into the event store by the\r\npersistence subscriber). Finally it returns the entity to the caller.\r\n\r\n```python\r\nfrom eventsourcing.domain.model.events import publish\r\nimport uuid\r\n\r\ndef register_new_example(a, b):\r\n    entity_id = uuid.uuid4().hex\r\n    event = Example.Created(entity_id=entity_id, a=a, b=b)\r\n    entity = Example.mutate(event=event)\r\n    publish(event=event)\r\n    return entity\r\n```\r\n\r\nThat's everything needed to create new entities. How can existing\r\nentities be obtained? Entities are retrieved from repositories.\r\n\r\nDefine an event sourced repository class for your entity. Inherit from\r\neventsourcing.infrastructure.event_sourced_repo.EventSourcedRepository\r\nand set the 'domain_class' attribute on the subclass.\r\n\r\n```python\r\nfrom eventsourcing.infrastructure.event_sourced_repo import EventSourcedRepository\r\n\r\nclass ExampleRepository(EventSourcedRepository):\r\n\r\n    domain_class = Example\r\n```\r\n\r\nApplication objects are used to bind domain and infrastructure. This\r\nnormally involves having some kind of stored event repository suitable\r\nfor the database system you want to use. The stored event repository is\r\nused by the event store, which is used by both the persistence\r\nsubscriber to make events durable, and by event players in repositories\r\nto get the events for an entity that has been requested.\r\n\r\nPlease note, for convenience when using SQLAlchemy or Cassandra to\r\nstore events, two application sub-classes are provided:\r\n'EventSourcingWithSQLAlchemy' and 'EventSourcingWithCassandra'.\r\n\r\nAdd an application class, inheriting from 'EventSourcingWithSQLAlchemy',\r\nthat has an event sourced repo. This inheritance provides a\r\npersistence subscriber, an event store, and a stored event repository\r\nthat works with SQLAlchemy.\r\n\r\n\r\n```python\r\nfrom eventsourcing.application.with_sqlalchemy import EventSourcingWithSQLAlchemy\r\n\r\nclass ExampleApplication(EventSourcingWithSQLAlchemy):\r\n\r\n    def __init__(self, **kwargs):\r\n        super(ExampleApplication, self).__init__(**kwargs)\r\n        self.example_repo = ExampleRepository(\r\n            event_store=self.event_store,\r\n        )\r\n\r\n```\r\n\r\nFor simplicity, this application has just one type of entity. A more\r\nrealistic application may involve several different types of entity,\r\nseveral factory methods, several entity repositories, and different\r\nevent sourced projections (mutator funtions).\r\n\r\nAs shown below, an event sourced application object can be used as a\r\ncontext manager, which closes the application at the end of the block.\r\n\r\nThe 'db_uri' arg is used in the application constructor to configure\r\nthe database connection. And also a True value for arg 'enable_occ' is\r\ngiven, so that optimistic concurrency control  is enabled. If you\r\naren't developing a distributed (or otherwise concurrent and\r\npotentially contentious) application, you don't need to\r\nenable optimistic concurrency control.\r\n\r\nWith an instance of the example application, call the factory method\r\nregister_new_entity() to register a new entity. Then, update an\r\nattribute value by assigning a value. Use the generated entity ID to\r\nsubsequently retrieve the registered entity from the repository. Check\r\nthe changed attribute value has been stored. Discard the entity and see\r\nthat the repository gives a key error when an attempt is made to obtain\r\nthe entity after it has been discarded:\r\n\r\n\r\n```python\r\ndb_uri = 'sqlite:///:memory:'\r\nwith ExampleApplication(db_uri=db_uri, enable_occ=True) as app:\r\n\r\n    # Register a new example.\r\n    example1 = register_new_example(a=1, b=2)\r\n\r\n    # Check the example is available in the repo.\r\n    assert example1.id in app.example_repo\r\n\r\n    # Check the attribute values.\r\n    entity1 = app.example_repo[example1.id]\r\n    assert entity1.a == 1\r\n    assert entity1.b == 2\r\n\r\n    # Change attribute values.\r\n    entity1.a = 123\r\n    entity1.b = 234\r\n\r\n    # Check the new values are available in the repo.\r\n    entity1 = app.example_repo[example1.id]\r\n    assert entity1.a == 123\r\n    assert entity1.b == 234\r\n\r\n    # Discard the entity.\r\n    entity1.discard()\r\n\r\n    assert example1.id not in app.example_repo\r\n\r\n    # Getting a discarded entity from the repo causes a KeyError.\r\n    try:\r\n        app.example_repo[example1.id]\r\n    except KeyError:\r\n        pass\r\n    else:\r\n        assert False\r\n```\r\n\r\nCongratulations! You have created a new event sourced application.\r\n\r\nIf you wanted also to enable application-level encryption, pass in a\r\ncipher, and a True value for 'always_encrypt_stored_events'. With\r\napplication level encryption, your data below the application will\r\nbe encrypted at rest and in transit, which can help prevent data loss.\r\n\r\n```python\r\nfrom eventsourcing.domain.services.cipher import AESCipher\r\n\r\ncipher = AESCipher(aes_key='0123456789abcdef')\r\n\r\nwith ExampleApplication(db_uri=db_uri, enable_occ=True, cipher=cipher,\r\n                        always_encrypt_stored_events=True):\r\n\r\n    # Register a new example.\r\n    example1 = register_new_example(a='secret data', b='more secrets')\r\n\r\n\r\n```\r\n\r\nIf you want to model other domain events, then simply declare them on\r\nthe entity class like the events above, and implement methods on the\r\nentity which instantiate those domain events, apply them to the entity,\r\npublish to subscribers. Add mutator functions to apply the domain\r\nevents to the entity objects, for example by directly changing the\r\ninternal state of the entity. See the beat_heart() method on the\r\nextended example application included in this distribution.\r\n\r\nThe example above uses an SQLite in memory relational database, but you\r\ncould change 'db_uri' to another connection string if you have a real\r\ndatabase. Here are some example connection strings - for an SQLite file,\r\nfor a PostgreSQL database, and for a MySQL database. See SQLAlchemy's\r\ncreate_engine() documentation for details.\r\n\r\n```\r\nsqlite:////tmp/mydatabase\r\n\r\npostgresql://scott:tiger@localhost:5432/mydatabase\r\n\r\nmysql://scott:tiger@hostname/dbname\r\n```\r\n\r\nTodo: Develop above to be a tutorial.\r\n\r\n\r\n### Upgrading From 1.0.x to 1.1.x\r\n\r\nYou don't need to do anything. However before using the new optimistic concurrency controls\r\nyou will need to migrate an existing database schema to have the new 'entity_versions' table,\r\nand you will also need to add a record to that table for each stored event. See notes in doc\r\nstring of EventSourcingApplication class for a zero-downtime migration approach.\r\n\r\nTo enable optimistic concurrency control, set the application constructor argument named\r\n'enable_occ' to a True value.\r\n\r\n\r\n### Upgrading From 0.9.4 to 1.0.x\r\n\r\nIf you are upgrading from version 0.9.4, or earlier, please note that version 0.9.4 is\r\nthe last version with ascending as the declared ordering of 'event_id' in column family 'cql_stored_event'.\r\nSubsequent versions have the this ordering declared as descending. The change was made to support both paging\r\nthrough long histories of events and getting only recent events after a snapshot.\r\n\r\nA few things have been renamed, for example '@mutableproperty' is the new name for '@eventsourcedproperty'.\r\nThis change was made to reflect the fact that immutable properties are also event sourced.\r\n\r\nThe EventSourcedEntity class now has a property 'created_on', which replaces the attribute '_created_on'.\r\nThis change follows from the fact that the domain events no longer have an floating point attribute 'timestamp'\r\nbut instead a UUID attribute 'domain_event_id', which is set on an event sourced entity as '_initial_event_id'.\r\nThat UUID value is used to generate the floating point timestamp value of the 'created_on' property.\r\n\r\nPlease note, the mutator style has changed to use the `singledispatch` package. Mutators were implemented as a\r\nbig if-elif-else block. Subclasses of EventSourcedEntity must implement a static method called _mutator() in\r\norder to have their own mutator function invoked when mutate() is called.\r\n\r\nThere is a new method called _apply() on EventSourcedEntity, which makes operations that need to apply events\r\nhave a suitably named method to call. The apply() method calls the mutate() class method, which is also used by the\r\nevent source repository to replay events. The mutate() class method calls the static method _mutator() with the\r\nevent and an initial state. So the static method _mutator is a good method to override in order to introduce\r\na mutator for the class.\r\n\r\nPlease see the Example class for details, and the documentation for singledispatch.\r\n\r\nAlso, for Cassandra users, the table name for stored events has changed to 'stored_events'. The column names\r\nhave changed to be single characters, for storage efficiency. Production data will need to be migrated.\r\n\r\n\r\n## Background\r\n\r\nAlthough the event sourcing patterns are each quite simple, and they can be reproduced in code for each project,\r\nthey do suggest cohesive mechanisms, for example applying and publishing the events generated within domain\r\nentities, storing and retrieving selections of the events in a highly scalable manner, replaying the stored\r\nevents for a particular entity to obtain the current state, and projecting views of the event stream that are\r\npersisted in other models. Quoting from the \"Cohesive Mechanism\" pages in Eric Evan's Domain Driven Design book:\r\n\r\n_\"Therefore: Partition a conceptually COHESIVE MECHANISM into a separate lightweight framework. Particularly watch\r\nfor formalisms for well-documented categories of algorithms. Expose the capabilities of the framework\r\nwith an INTENTION-REVEALING INTERFACE. Now the other elements of the domain can focus on expressing the problem\r\n(\"what\"), delegating the intricacies of the solution (\"how\") to the framework.\"_\r\n\r\nThe example usage (see above) introduces the \"interface\". The \"intricacies\" can be found in the source code.\r\n\r\nInspiration:\r\n\r\n* Martin Fowler's article on event sourcing\r\n    * http://martinfowler.com/eaaDev/EventSourcing.html\r\n\r\n* Greg Young's discussions about event sourcing, and EventStore system\r\n    * https://www.youtube.com/watch?v=JHGkaShoyNs\r\n    * https://www.youtube.com/watch?v=LDW0QWie21s\r\n    * https://dl.dropboxusercontent.com/u/9162958/CQRS/Events%20as%20a%20Storage%20Mechanism%20CQRS.pdf\r\n    * https://geteventstore.com/\r\n\r\n* Robert Smallshire's brilliant example code on Bitbucket\r\n    * https://bitbucket.org/sixty-north/d5-kanban-python/src\r\n\r\n* Various professional projects that called for this approach, across which I didn't want to rewrite\r\n  the same things each time\r\n\r\n\r\nSee also:\r\n\r\n* 'Evaluation of using NoSQL databases in an event sourcing system' by Johan Rothsberg\r\n    * http://www.diva-portal.se/smash/get/diva2:877307/FULLTEXT01.pdf\r\n\r\n* Wikipedia page on Object-relational impedance mismatch\r\n    * https://en.wikipedia.org/wiki/Object-relational_impedance_mismatch\r\n\r\n\r\n## More Details About the Features\r\n\r\n* Example application of event sourcing, with an example event sourced entity and example domain events, and with\r\n an example event sourced repository containing example entity instances, and an example entity factory method\r\n\r\n* Storage-specific event sourced application classes\r\n\r\n    * Base class for event sourced applications with SQLAlchemy\r\n\r\n    * Base class for event sourced applications with Cassandra\r\n\r\n    * Base class for event sourced applications with simple Python objects (non-persistent)\r\n\r\n* Base class for event sourced applications, which provides an event store and a persistence subscriber, but\r\n which requires subclasses to implement a method that provides a stored event repository instance\r\n\r\n* Example event sourced entity\r\n\r\n* Base class for event sourced entities\r\n\r\n    * Basic domain events, to model basic \"created\", \"attribute changed\", and \"discarded\" entity events\r\n\r\n    * Mutator function, to apply a domain event to an entity, variously according to the type of the event\r\n\r\n    * Event sourced property decorator, to help declare simple event sourced properties\r\n\r\n    * A \"discard\" method which publishes the discarded event, to call when an entity is no longer wanted,\r\n\r\n* Domain event base class, to model events in a domain\r\n\r\n* In-process publish-subscribe mechanism, for in-process domain event propagation\r\n\r\n* Persistence subscriber class, to subscribe to locally published domain events and append them to an event store\r\n\r\n* Example event sourced domain entity repository\r\n\r\n* Base class for event sourced domain entity repositories\r\n\r\n* Event player, to recover a domain entity for a given domain entity ID, using an event store and a mutator\r\n\r\n* Domain event store class\r\n\r\n    * Method to append a new domain event\r\n\r\n    * Method to get all the domain events for an entity\r\n\r\n* Concrete stored event repository classes\r\n\r\n    * Stored event repository to persist stored event objects in a relational database, using SQLAlchemy (as an ORM)\r\n\r\n    * Stored event repository to persist stored events in Cassandra\r\n\r\n    * Stored event repository using simple Python objects (non-persistent)\r\n\r\n* Generic stored event class, to provide a form in which to persist domain events\r\n\r\n* Function to get event topic from domain event class\r\n\r\n* Function to resolve event topic into domain event class\r\n\r\n* Function to serialize a domain event object to a stored event object\r\n\r\n* Function to recreate a domain event object from a stored event object\r\n\r\n* Base class for stored event repositories\r\n\r\n    * Method to append a new stored event to the stored collection\r\n\r\n    * Method to get all stored events for given entity ID\r\n\r\n    * Method to get all stored events for given domain event topic\r\n\r\n    * Method to get single domain event for given event ID\r\n\r\n* Entity snapshots, to avoid replaying all events\r\n\r\n* Method to get domain events for given entity ID, from given time\r\n\r\n* Method to get domain events for given entity ID, until given time\r\n\r\n* Method to get a limited number of domain events\r\n\r\n* Generator that retrieves events in a succession of pages, emitting a\r\n continuous stream in ascending or descending order\r\n\r\n* Time-bucketed logs, useful for accumulating an indefinite list of\r\n messages in an accessible manner\r\n\r\n* Encrypted stored events, providing application level encryption\r\n\r\n* Set-based collections\r\n\r\n* Optimistic concurrency control\r\n\r\n* Generalized suffix trees\r\n\r\nTodo: Develop above to be an API reference.\r\n\r\n\r\n## Forthcoming Features\r\n\r\n* List-based collections (forthcoming)\r\n\r\n* Stored event repository to persist stored events in a file using a\r\n very simple file format (forthcoming)\r\n\r\n* Stored event repository to persist stored events using MongoDB (forthcoming)\r\n\r\n* Stored event repository to persist stored events using HBase (forthcoming)\r\n\r\n* Stored event repository to persist stored events using DynamoDB (forthcoming)\r\n\r\n* Method to delete all domain events for given domain entity ID (forthcoming)\r\n\r\n* Method to get all domain events in the order they occurred (forthcoming)\r\n\r\n* Storage retries and fallback strategies, to protect against failing to write an event (forthcoming)\r\n\r\n* Subscriber that publishes domain events to RabbitMQ (forthcoming)\r\n\r\n* Subscriber that publishes domain events to Amazon SQS (forthcoming)\r\n\r\n* Republisher that subscribes to RabbitMQ and publishes domain events locally (forthcoming)\r\n\r\n* Republisher that subscribers to Amazon SQS and publishes domain event locally (forthcoming)\r\n\r\n* Linked pages of domain events (\"Archived Log\"), to allow event sourced projections easily to make sure they have\r\nall the events (forthcoming)\r\n\r\n* Base class for event sourced projections or views (forthcoming)\r\n\r\n    * In memory event sourced projection, which needs to replay entire event stream when system starts up (forthcoming)\r\n\r\n    * Persistent event sourced projection, which stored its projected state, but needs to replay entire event stream\r\n      when initialized  (forthcoming)\r\n\r\n* Event sourced indexes, as persisted event source projections, to discover extant entity IDs (forthcoming)\r\n\r\n* Event pointer, to refer to an event in a stream (forthcoming)\r\n\r\n* Updating stored events, to support domain model migration (forthcoming)\r\n\r\n* Something to store serialized event attribute values separately from the other event information, to prevent large\r\nattribute values inhibiting performance and stability - different sizes could be stored in different ways...\r\n(forthcoming)\r\n\r\n* Different kinds of stored event\r\n    * IDs generated from content, e.g. like Git (forthcoming)\r\n    * cryptographically signed stored events (forthcoming)\r\n\r\n* Branch and merge mechanism for domain events (forthcoming)\r\n\r\n* Support for asynchronous I/O, with an application that uses an event loop (forthcoming)\r\n\r\n* More examples (forthcoming)\r\n\r\n* Great documentation! (forthcoming)\r\n\r\n* Context maps (so we can use univerally unique IDs within a context,\r\n  even though entities arise from other contexts and may not have\r\n  universally unique IDs e.g. integer sequences)\r\n\r\n* Optionally decouple topics from actual code, so classes can be moved.\r\n\r\nTodo: Develop above to be a release plan.\r\n\r\n\r\n## Possible Future Backwards-Incompatible Changes\r\n\r\n* Remove id_prefixes in stored entity ID, because it makes the code a\r\n  bit complicated, since each domain event needs to know which entity\r\n  class it is for, and that's not always desirable. This would involve\r\n  internal code changes that probably wouldn't impact on applications\r\n  using this package, however it would impact existing data. This\r\n  change might not even be a good idea.\r\n\r\n* Move base event classes off from abstract entity classes, so developers\r\n  can't get confused with events defined on super classes that can't be\r\n  retrieved from the event store, because they don't know which concrete\r\n  class they pertain to, so can't be written with correct id prefixes.\r\n  This would be a code change rather than a data migration thing. This\r\n  wouldn't be an issue if we didn't use ID prefixes.\r\n\r\n* Stored event repositories that primarily use version numbers instead\r\n  of UUIDs to key and order stored events. This wouldn't be a backwards\r\n  incompatible change, but an alternative transcoder and stored\r\n  event repo.\r\n\r\n\r\n## Project\r\n\r\nThis project is hosted on GitHub.\r\n\r\n* https://github.com/johnbywater/eventsourcing\r\n\r\n\r\nQuestions, requests and any other issues can be registered here:\r\n\r\n* https://github.com/johnbywater/eventsourcing/issues\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}